schema {
  query: Query
  mutation: Mutation
}

"Information about Anime."
type Anime {
  "Anime Id"
  id: UUID!
  "Variants of anime titles in different languages"
  titles: [AnimeTitle!]!
  "Variants of anime synopsises in different languages"
  synopsises: [AnimeSynopsis!]
  "Various options for posters"
  posters: [AnimePoster!]
  "Various options for covers"
  covers: [AnimeCover!]
  "List of anime genres"
  genres: [AnimeGenre!]
  "The number of series (indicate which series. Those that came out, or should there be?)"
  numEpisodes: Int
  "Premiere date"
  premier: Premier
  "Anime type"
  type: AnimeType!
  "Average episode duration"
  episodesDurationSeconds: Int
  "List of anime characters"
  characters: [AnimeCharacter!]
  "Anime broadcast period"
  aired: Aired
  "Anime release status"
  airingStatus: AiringStatus!
  "Age restrictions"
  ageRating: AgeRating!
  "Primary source"
  source: Source!
  "List of services with information about the title"
  anotherService: AnotherAnimeService!
  favoriteInUsers: [UserFavoriteAnime!]!
}

"Information about User."
type NekoUser {
  "User Id"
  id: String
  "Information about yourself provided by the user"
  about: String
  "A unique nickname invented by the user"
  userName: String
  "User Email address"
  email: String
  "Is the email сonfirmed"
  emailConfirmed: Boolean!
  "Gets a flag indicating if the user could be lock out"
  lockoutEnabled: Boolean!
  "Get date and time, int UTC, when user lockout ends"
  lockoutEnd: DateTime
  favoriteAnimes: [UserFavoriteAnime!]!
  ratingAnimes: [UserRatingAnime!]!
  animeViewingStatuses: [UserAnimeViewingStatus!]!
  securityStamp: String
}

"Information about Anime titles."
type AnimeTitle {
  "Title Id"
  id: UUID!
  "Belongs to this anime"
  anime: Anime!
  "The main option"
  isMain: Boolean!
  "Option name"
  body: String!
  "The date of the offer"
  createdAt: DateTime!
  "Offer provided by this user"
  creatorUserId: UUID
  "Is the offer accepted?"
  isAcceptProposal: Boolean
  "Hiding the field"
  isHidden: Boolean!
  "Is this the official name"
  isOriginal: Boolean!
  "Translation language"
  language: Languages!
  "Id media belongs"
  mediaId: UUID!
  "Time of last update"
  updatedAt: DateTime!
  from: ItemFrom!
  media: Anime!
  animeId: UUID!
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

type Query {
  anime("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: AnimeFilterInput order: [AnimeSortInput!]): AnimeConnection
  searchAnimeByName(input: SearchInput!): [AnimeTitle!]!
  me: NekoUser!
  checkClaim: [Boolean!]!
}

type Mutation {
  test: [Anime!]!
  runSeeding(input: AddSeedingInput!): AddSeedingPayload!
  createTranslationProposal(input: CreateTranslationProposalInput!): CreateTranslationProposalPayload!
  setDecisionTranslationProposal(input: SetDecisionTranslationProposalInput!): SetDecisionTranslationProposalPayload!
  setMainTitleInput(input: SetMainTitleInput!): SetMainTitleInputPayload!
  updateAnimeTitle(input: AnimeTypeItemInput!): AnimeTypeItemPayload!
  updateUser(input: UserInput!): UserPayload!
  updateUserLibraryEntry(input: UserLibraryEntryInput!): UserLibraryEntryPayload!
}

scalar UUID

type AnimeSynopsis {
  id: UUID!
  body: String!
  language: Languages!
  from: ItemFrom!
  isMain: Boolean!
  isOriginal: Boolean!
  mediaId: UUID!
  media: Anime!
  animeId: UUID!
  anime: Anime!
  isAcceptProposal: Boolean
  isHidden: Boolean!
  creatorUserId: UUID
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnimePoster {
  animeId: UUID!
  anime: Anime!
  posterId: Int!
  poster: Image!
}

type AnimeCover {
  animeId: UUID!
  anime: Anime!
  coverId: Int!
  cover: Image!
}

type AnimeGenre {
  animeId: UUID!
  anime: Anime!
  genreId: Int!
  genre: Genre!
}

type Premier {
  id: UUID!
  year: Int
  sezon: Sezon!
}

enum AnimeType {
  EVERY_TYPE
  TV
  OVA
  MOVIE
  SPECIAL
  ONA
  MUSIC
  UNKNOWN
}

type AnimeCharacter {
  animeId: UUID!
  anime: Anime!
  characterId: UUID!
  character: Character!
}

type Aired {
  id: UUID!
  from: DateTime
  to: DateTime
}

enum AiringStatus {
  FINISHED_AIRING
  CURRENTLY_AIRING
  NOT_YET_AIRED
  UNKNOWN
}

enum AgeRating {
  G
  PG
  PG13
  R17
  R
  RX
  UNKNOWN
}

enum Source {
  OTHER
  ORIGINAL
  MANGA
  FOR_KOMA_MANGA
  WEB_MANGA
  DIGITAL_MANGA
  NOVEL
  LIGHT_NOVEL
  VISUAL_NOVEL
  GAME
  CARD_GAME
  BOOK
  PICTURE_BOOK
  RADIO
  MUSIC
  UNDEFINED
}

type AnotherAnimeService {
  kitsuId: Int
  notifyId: String
  animePlanetId: String
  aniSearchId: Int
  livechartMeId: Int
  myAnimeList: Int
  id: UUID!
  animeDBId: Int
  anilistId: Int
}

type UserFavoriteAnime {
  animeId: UUID!
  anime: Anime!
  userId: String!
  user: NekoUser!
  createdAt: DateTime!
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

type UserRatingAnime {
  ratingValue: Float!
  animeId: UUID!
  anime: Anime!
  userId: String!
  user: NekoUser!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAnimeViewingStatus {
  status: UserViewStatus!
  animeId: UUID!
  anime: Anime!
  userId: String!
  user: NekoUser!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum Languages {
  UK
  PL
  EN
  JA
  UND
}

enum ItemFrom {
  SYSTEM
  USER
  EXTERNAL_SOURCE
}

input AnimeFilterInput {
  and: [AnimeFilterInput!]
  or: [AnimeFilterInput!]
  id: ComparableGuidOperationFilterInput
  titles: ListFilterInputTypeOfAnimeTitleFilterInput
  synopsises: ListFilterInputTypeOfAnimeSynopsisFilterInput
  type: AnimeTypeOperationFilterInput
  airingStatus: AiringStatusOperationFilterInput
  ageRating: AgeRatingOperationFilterInput
  source: SourceOperationFilterInput
  genres: ListFilterInputTypeOfAnimeGenreFilterInput
  characters: ListFilterInputTypeOfAnimeCharacterFilterInput
  numEpisodes: ComparableNullableOfInt32OperationFilterInput
  episodesDurationSeconds: ComparableNullableOfInt32OperationFilterInput
  premier: PremierFilterInput
  aired: AiredFilterInput
  posters: ListFilterInputTypeOfAnimePosterFilterInput
  covers: ListFilterInputTypeOfAnimeCoverFilterInput
  anotherService: AnotherAnimeServiceFilterInput
  favoriteInUsers: ListFilterInputTypeOfUserFavoriteAnimeFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input AnimeSortInput {
  id: SortEnumType
  type: SortEnumType
  airingStatus: SortEnumType
  ageRating: SortEnumType
  source: SortEnumType
  numEpisodes: SortEnumType
  episodesDurationSeconds: SortEnumType
  premier: PremierSortInput
  aired: AiredSortInput
  anotherService: AnotherAnimeServiceSortInput
  createdAt: SortEnumType
  updatedAt: SortEnumType
}

"A connection to a list of items."
type AnimeConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [AnimeEdge!]
  "A flattened list of the nodes."
  nodes: [Anime!]
  totalCount: Int!
}

input ComparableGuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID!]
  nin: [UUID!]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input ListFilterInputTypeOfAnimeTitleFilterInput {
  all: AnimeTitleFilterInput
  none: AnimeTitleFilterInput
  some: AnimeTitleFilterInput
  any: Boolean
}

input ListFilterInputTypeOfAnimeSynopsisFilterInput {
  all: AnimeSynopsisFilterInput
  none: AnimeSynopsisFilterInput
  some: AnimeSynopsisFilterInput
  any: Boolean
}

input AnimeTypeOperationFilterInput {
  eq: AnimeType
  neq: AnimeType
  in: [AnimeType!]
  nin: [AnimeType!]
}

input AiringStatusOperationFilterInput {
  eq: AiringStatus
  neq: AiringStatus
  in: [AiringStatus!]
  nin: [AiringStatus!]
}

input AgeRatingOperationFilterInput {
  eq: AgeRating
  neq: AgeRating
  in: [AgeRating!]
  nin: [AgeRating!]
}

input SourceOperationFilterInput {
  eq: Source
  neq: Source
  in: [Source!]
  nin: [Source!]
}

input ListFilterInputTypeOfAnimeGenreFilterInput {
  all: AnimeGenreFilterInput
  none: AnimeGenreFilterInput
  some: AnimeGenreFilterInput
  any: Boolean
}

input ListFilterInputTypeOfAnimeCharacterFilterInput {
  all: AnimeCharacterFilterInput
  none: AnimeCharacterFilterInput
  some: AnimeCharacterFilterInput
  any: Boolean
}

input ComparableNullableOfInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input PremierFilterInput {
  and: [PremierFilterInput!]
  or: [PremierFilterInput!]
  id: ComparableGuidOperationFilterInput
  year: ComparableNullableOfInt32OperationFilterInput
  sezon: SezonOperationFilterInput
}

input AiredFilterInput {
  and: [AiredFilterInput!]
  or: [AiredFilterInput!]
  id: ComparableGuidOperationFilterInput
  from: ComparableNullableOfDateTimeOperationFilterInput
  to: ComparableNullableOfDateTimeOperationFilterInput
}

input ListFilterInputTypeOfAnimePosterFilterInput {
  all: AnimePosterFilterInput
  none: AnimePosterFilterInput
  some: AnimePosterFilterInput
  any: Boolean
}

input ListFilterInputTypeOfAnimeCoverFilterInput {
  all: AnimeCoverFilterInput
  none: AnimeCoverFilterInput
  some: AnimeCoverFilterInput
  any: Boolean
}

input AnotherAnimeServiceFilterInput {
  and: [AnotherAnimeServiceFilterInput!]
  or: [AnotherAnimeServiceFilterInput!]
  kitsuId: ComparableNullableOfInt32OperationFilterInput
  notifyId: StringOperationFilterInput
  animePlanetId: StringOperationFilterInput
  aniSearchId: ComparableNullableOfInt32OperationFilterInput
  livechartMeId: ComparableNullableOfInt32OperationFilterInput
  myAnimeList: ComparableNullableOfInt32OperationFilterInput
  id: ComparableGuidOperationFilterInput
  animeDBId: ComparableNullableOfInt32OperationFilterInput
  anilistId: ComparableNullableOfInt32OperationFilterInput
}

input ListFilterInputTypeOfUserFavoriteAnimeFilterInput {
  all: UserFavoriteAnimeFilterInput
  none: UserFavoriteAnimeFilterInput
  some: UserFavoriteAnimeFilterInput
  any: Boolean
}

input ComparableDateTimeOffsetOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

enum SortEnumType {
  ASC
  DESC
}

input PremierSortInput {
  id: SortEnumType
  year: SortEnumType
  sezon: SortEnumType
}

input AiredSortInput {
  id: SortEnumType
  from: SortEnumType
  to: SortEnumType
}

input AnotherAnimeServiceSortInput {
  kitsuId: SortEnumType
  notifyId: SortEnumType
  animePlanetId: SortEnumType
  aniSearchId: SortEnumType
  livechartMeId: SortEnumType
  myAnimeList: SortEnumType
  id: SortEnumType
  animeDBId: SortEnumType
  anilistId: SortEnumType
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

"An edge in a connection."
type AnimeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Anime!
}

input AnimeTitleFilterInput {
  and: [AnimeTitleFilterInput!]
  or: [AnimeTitleFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isMain: BooleanOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: AnimeFilterInput
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  isHidden: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input AnimeSynopsisFilterInput {
  and: [AnimeSynopsisFilterInput!]
  or: [AnimeSynopsisFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isMain: BooleanOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: AnimeFilterInput
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  isHidden: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input AnimeGenreFilterInput {
  and: [AnimeGenreFilterInput!]
  or: [AnimeGenreFilterInput!]
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  genreId: ComparableInt32OperationFilterInput
  genre: GenreFilterInput
}

input AnimeCharacterFilterInput {
  and: [AnimeCharacterFilterInput!]
  or: [AnimeCharacterFilterInput!]
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
}

input SezonOperationFilterInput {
  eq: Sezon
  neq: Sezon
  in: [Sezon!]
  nin: [Sezon!]
}

input ComparableNullableOfDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input AnimePosterFilterInput {
  and: [AnimePosterFilterInput!]
  or: [AnimePosterFilterInput!]
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  posterId: ComparableInt32OperationFilterInput
  poster: ImageFilterInput
}

input AnimeCoverFilterInput {
  and: [AnimeCoverFilterInput!]
  or: [AnimeCoverFilterInput!]
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  coverId: ComparableInt32OperationFilterInput
  cover: ImageFilterInput
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input UserFavoriteAnimeFilterInput {
  and: [UserFavoriteAnimeFilterInput!]
  or: [UserFavoriteAnimeFilterInput!]
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  userId: StringOperationFilterInput
  user: NekoUserFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
}

input LanguagesOperationFilterInput {
  eq: Languages
  neq: Languages
  in: [Languages!]
  nin: [Languages!]
}

input ItemFromOperationFilterInput {
  eq: ItemFrom
  neq: ItemFrom
  in: [ItemFrom!]
  nin: [ItemFrom!]
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input ComparableNullableOfGuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input GenreFilterInput {
  and: [GenreFilterInput!]
  or: [GenreFilterInput!]
  id: ComparableInt32OperationFilterInput
  name: StringOperationFilterInput
  animes: ListFilterInputTypeOfAnimeGenreFilterInput
  mangas: ListFilterInputTypeOfMangaGenreFilterInput
}

input CharacterFilterInput {
  and: [CharacterFilterInput!]
  or: [CharacterFilterInput!]
  id: ComparableGuidOperationFilterInput
  names: ListFilterInputTypeOfCharacterNamesFilterInput
  abouts: ListFilterInputTypeOfCharacterAboutFilterInput
  posters: ListFilterInputTypeOfCharacterPosterFilterInput
  covers: ListFilterInputTypeOfCharacterCoverFilterInput
  animes: ListFilterInputTypeOfAnimeCharacterFilterInput
  mangas: ListFilterInputTypeOfMangaCharacterFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input ImageFilterInput {
  and: [ImageFilterInput!]
  or: [ImageFilterInput!]
  id: ComparableInt32OperationFilterInput
  original: StringOperationFilterInput
  large: StringOperationFilterInput
  medium: StringOperationFilterInput
  small: StringOperationFilterInput
  from: ItemFromOperationFilterInput
  posters: AnimePosterFilterInput
}

input NekoUserFilterInput {
  and: [NekoUserFilterInput!]
  or: [NekoUserFilterInput!]
  about: StringOperationFilterInput
  favoriteAnimes: ListFilterInputTypeOfUserFavoriteAnimeFilterInput
  ratingAnimes: ListFilterInputTypeOfUserRatingAnimeFilterInput
  animeViewingStatuses: ListFilterInputTypeOfUserAnimeViewingStatusFilterInput
  id: StringOperationFilterInput
  userName: StringOperationFilterInput
  normalizedUserName: StringOperationFilterInput
  email: StringOperationFilterInput
  normalizedEmail: StringOperationFilterInput
  emailConfirmed: BooleanOperationFilterInput
  passwordHash: StringOperationFilterInput
  securityStamp: StringOperationFilterInput
  concurrencyStamp: StringOperationFilterInput
  phoneNumber: StringOperationFilterInput
  phoneNumberConfirmed: BooleanOperationFilterInput
  twoFactorEnabled: BooleanOperationFilterInput
  lockoutEnd: ComparableNullableOfDateTimeOffsetOperationFilterInput
  lockoutEnabled: BooleanOperationFilterInput
  accessFailedCount: ComparableInt32OperationFilterInput
}

input ListFilterInputTypeOfMangaGenreFilterInput {
  all: MangaGenreFilterInput
  none: MangaGenreFilterInput
  some: MangaGenreFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCharacterNamesFilterInput {
  all: CharacterNamesFilterInput
  none: CharacterNamesFilterInput
  some: CharacterNamesFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCharacterAboutFilterInput {
  all: CharacterAboutFilterInput
  none: CharacterAboutFilterInput
  some: CharacterAboutFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCharacterPosterFilterInput {
  all: CharacterPosterFilterInput
  none: CharacterPosterFilterInput
  some: CharacterPosterFilterInput
  any: Boolean
}

input ListFilterInputTypeOfCharacterCoverFilterInput {
  all: CharacterCoverFilterInput
  none: CharacterCoverFilterInput
  some: CharacterCoverFilterInput
  any: Boolean
}

input ListFilterInputTypeOfMangaCharacterFilterInput {
  all: MangaCharacterFilterInput
  none: MangaCharacterFilterInput
  some: MangaCharacterFilterInput
  any: Boolean
}

input ListFilterInputTypeOfUserRatingAnimeFilterInput {
  all: UserRatingAnimeFilterInput
  none: UserRatingAnimeFilterInput
  some: UserRatingAnimeFilterInput
  any: Boolean
}

input ListFilterInputTypeOfUserAnimeViewingStatusFilterInput {
  all: UserAnimeViewingStatusFilterInput
  none: UserAnimeViewingStatusFilterInput
  some: UserAnimeViewingStatusFilterInput
  any: Boolean
}

input ComparableNullableOfDateTimeOffsetOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input MangaGenreFilterInput {
  and: [MangaGenreFilterInput!]
  or: [MangaGenreFilterInput!]
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  genreId: ComparableInt32OperationFilterInput
  genre: GenreFilterInput
}

input CharacterNamesFilterInput {
  and: [CharacterNamesFilterInput!]
  or: [CharacterNamesFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  isMain: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: CharacterFilterInput
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input CharacterAboutFilterInput {
  and: [CharacterAboutFilterInput!]
  or: [CharacterAboutFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  isMain: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: CharacterFilterInput
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input CharacterPosterFilterInput {
  and: [CharacterPosterFilterInput!]
  or: [CharacterPosterFilterInput!]
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
  posterId: ComparableInt32OperationFilterInput
  poster: ImageFilterInput
}

input CharacterCoverFilterInput {
  and: [CharacterCoverFilterInput!]
  or: [CharacterCoverFilterInput!]
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
  coverId: ComparableInt32OperationFilterInput
  cover: ImageFilterInput
}

input MangaCharacterFilterInput {
  and: [MangaCharacterFilterInput!]
  or: [MangaCharacterFilterInput!]
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  characterId: ComparableGuidOperationFilterInput
  character: CharacterFilterInput
}

input UserRatingAnimeFilterInput {
  and: [UserRatingAnimeFilterInput!]
  or: [UserRatingAnimeFilterInput!]
  ratingValue: ComparableSingleOperationFilterInput
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  userId: StringOperationFilterInput
  user: NekoUserFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input UserAnimeViewingStatusFilterInput {
  and: [UserAnimeViewingStatusFilterInput!]
  or: [UserAnimeViewingStatusFilterInput!]
  status: UserViewStatusOperationFilterInput
  animeId: ComparableGuidOperationFilterInput
  anime: AnimeFilterInput
  userId: StringOperationFilterInput
  user: NekoUserFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input MangaFilterInput {
  and: [MangaFilterInput!]
  or: [MangaFilterInput!]
  id: ComparableGuidOperationFilterInput
  titles: ListFilterInputTypeOfMangaTitleFilterInput
  synopsises: ListFilterInputTypeOfMangaSynopsisFilterInput
  posters: ListFilterInputTypeOfMangaPosterFilterInput
  covers: ListFilterInputTypeOfMangaCoverFilterInput
  chaptersCount: ComparableInt32OperationFilterInput
  genres: ListFilterInputTypeOfMangaGenreFilterInput
  characters: ListFilterInputTypeOfMangaCharacterFilterInput
  published: PublishedFilterInput
  publishing: BooleanOperationFilterInput
  readStatus: MangaStatusOperationFilterInput
  type: MangaTypeOperationFilterInput
  volumes: ComparableInt32OperationFilterInput
  anotherService: AnotherMangaServiceFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input ComparableSingleOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input UserViewStatusOperationFilterInput {
  eq: UserViewStatus
  neq: UserViewStatus
  in: [UserViewStatus!]
  nin: [UserViewStatus!]
}

input ListFilterInputTypeOfMangaTitleFilterInput {
  all: MangaTitleFilterInput
  none: MangaTitleFilterInput
  some: MangaTitleFilterInput
  any: Boolean
}

input ListFilterInputTypeOfMangaSynopsisFilterInput {
  all: MangaSynopsisFilterInput
  none: MangaSynopsisFilterInput
  some: MangaSynopsisFilterInput
  any: Boolean
}

input ListFilterInputTypeOfMangaPosterFilterInput {
  all: MangaPosterFilterInput
  none: MangaPosterFilterInput
  some: MangaPosterFilterInput
  any: Boolean
}

input ListFilterInputTypeOfMangaCoverFilterInput {
  all: MangaCoverFilterInput
  none: MangaCoverFilterInput
  some: MangaCoverFilterInput
  any: Boolean
}

input PublishedFilterInput {
  and: [PublishedFilterInput!]
  or: [PublishedFilterInput!]
  id: ComparableGuidOperationFilterInput
  from: ComparableNullableOfDateTimeOperationFilterInput
  to: ComparableNullableOfDateTimeOperationFilterInput
}

input MangaStatusOperationFilterInput {
  eq: MangaStatus
  neq: MangaStatus
  in: [MangaStatus!]
  nin: [MangaStatus!]
}

input MangaTypeOperationFilterInput {
  eq: MangaType
  neq: MangaType
  in: [MangaType!]
  nin: [MangaType!]
}

input AnotherMangaServiceFilterInput {
  and: [AnotherMangaServiceFilterInput!]
  or: [AnotherMangaServiceFilterInput!]
  id: ComparableGuidOperationFilterInput
  animeDBId: ComparableNullableOfInt32OperationFilterInput
  anilistId: ComparableNullableOfInt32OperationFilterInput
}

input MangaTitleFilterInput {
  and: [MangaTitleFilterInput!]
  or: [MangaTitleFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isMain: BooleanOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: MangaFilterInput
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input MangaSynopsisFilterInput {
  and: [MangaSynopsisFilterInput!]
  or: [MangaSynopsisFilterInput!]
  id: ComparableGuidOperationFilterInput
  body: StringOperationFilterInput
  language: LanguagesOperationFilterInput
  from: ItemFromOperationFilterInput
  isMain: BooleanOperationFilterInput
  isOriginal: BooleanOperationFilterInput
  mediaId: ComparableGuidOperationFilterInput
  media: MangaFilterInput
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  isAcceptProposal: BooleanOperationFilterInput
  creatorUserId: ComparableNullableOfGuidOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  updatedAt: ComparableDateTimeOffsetOperationFilterInput
}

input MangaPosterFilterInput {
  and: [MangaPosterFilterInput!]
  or: [MangaPosterFilterInput!]
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  posterId: ComparableInt32OperationFilterInput
  poster: ImageFilterInput
}

input MangaCoverFilterInput {
  and: [MangaCoverFilterInput!]
  or: [MangaCoverFilterInput!]
  mangaId: ComparableGuidOperationFilterInput
  manga: MangaFilterInput
  coverId: ComparableInt32OperationFilterInput
  cover: ImageFilterInput
}

type Character {
  id: UUID!
  names: [CharacterNames!]!
  abouts: [CharacterAbout!]!
  posters: [CharacterPoster!]!
  covers: [CharacterCover!]!
  animes: [AnimeCharacter!]!
  mangas: [MangaCharacter!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum Sezon {
  WINTER
  SPRING
  SUMMER
  AUTUMN
  UNDEFINED
}

type Genre {
  id: Int!
  name: String!
  animes: [AnimeGenre!]!
  mangas: [MangaGenre!]!
}

type Image {
  id: Int!
  original: String!
  large: String
  medium: String
  small: String
  from: ItemFrom!
  posters: AnimePoster!
}

input UserLibraryEntryInput {
  animeId: UUID!
  isFavorite: Boolean
  ratingValue: Float
  viewStatus: UserViewStatus
}

type UserLibraryEntryPayload {
  user: NekoUser
  error: String
}

input UserInput {
  about: String
}

type UserPayload {
  user: NekoUser!
}

input AnimeTypeItemInput {
  titleId: UUID!
  isOriginal: Boolean
  body: String
  isHiden: Boolean
}

type AnimeTypeItemPayload {
  animeTitle: AnimeTitle
  error: String
}

input SetMainTitleInput {
  titleId: UUID!
  isMain: Boolean!
}

type SetMainTitleInputPayload {
  animeTitle: AnimeTitle
  error: String
}

input SetDecisionTranslationProposalInput {
  titleId: UUID!
  decision: DecisionVariants!
}

type SetDecisionTranslationProposalPayload {
  animeTitle: AnimeTitle!
}

input CreateTranslationProposalInput {
  animeId: UUID!
  proposition: String!
  language: Languages!
}

type CreateTranslationProposalPayload {
  isSucces: Boolean!
}

input AddSeedingInput {
  offset: Int
  page: Int
  inRecreateDB: Boolean
}

type AddSeedingPayload {
  anime: [Anime!]!
}

input SearchInput {
  query: String!
  first: Int!
}

enum UserViewStatus {
  WATCHING
  COMPLETED
  ON_HOLD
  DROPPED
  PLAN_TO_WATCH
}

enum MangaStatus {
  EVERY_STATUS
  REDING
  COMPLETED
  UPCOMING
}

enum MangaType {
  EVERY_TYPE
  MANGA
  NOVEL
  ONE_SHOT
  DOUJINSHI
  MANHWA
  MANHUA
}

enum DecisionVariants {
  ACCEPT
  REJECT
}

type MangaGenre {
  mangaId: UUID!
  manga: Manga!
  genreId: Int!
  genre: Genre!
}

type MangaCharacter {
  mangaId: UUID!
  manga: Manga!
  characterId: UUID!
  character: Character!
}

type CharacterCover {
  characterId: UUID!
  character: Character!
  coverId: Int!
  cover: Image!
}

type CharacterPoster {
  characterId: UUID!
  character: Character!
  posterId: Int!
  poster: Image!
}

type CharacterAbout {
  id: UUID!
  body: String!
  language: Languages!
  from: ItemFrom!
  isOriginal: Boolean!
  isMain: Boolean!
  mediaId: UUID!
  media: Character!
  characterId: UUID!
  character: Character!
  isAcceptProposal: Boolean
  creatorUserId: UUID
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CharacterNames {
  id: UUID!
  body: String!
  language: Languages!
  from: ItemFrom!
  isOriginal: Boolean!
  isMain: Boolean!
  mediaId: UUID!
  media: Character!
  characterId: UUID!
  character: Character!
  isAcceptProposal: Boolean
  creatorUserId: UUID
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Manga {
  id: UUID!
  titles: [MangaTitle!]!
  synopsises: [MangaSynopsis!]!
  posters: [MangaPoster!]!
  covers: [MangaCover!]!
  chaptersCount: Int!
  genres: [MangaGenre!]!
  characters: [MangaCharacter!]!
  published: Published!
  publishing: Boolean!
  readStatus: MangaStatus!
  type: MangaType!
  volumes: Int!
  anotherService: AnotherMangaService!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnotherMangaService {
  id: UUID!
  animeDBId: Int
  anilistId: Int
}

type Published {
  id: UUID!
  from: DateTime
  to: DateTime
}

type MangaCover {
  mangaId: UUID!
  manga: Manga!
  coverId: Int!
  cover: Image!
}

type MangaPoster {
  mangaId: UUID!
  manga: Manga!
  posterId: Int!
  poster: Image!
}

type MangaSynopsis {
  id: UUID!
  body: String!
  language: Languages!
  from: ItemFrom!
  isMain: Boolean!
  isOriginal: Boolean!
  mediaId: UUID!
  media: Manga!
  mangaId: UUID!
  manga: Manga!
  isAcceptProposal: Boolean
  creatorUserId: UUID
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MangaTitle {
  id: UUID!
  body: String!
  language: Languages!
  from: ItemFrom!
  isMain: Boolean!
  isOriginal: Boolean!
  mediaId: UUID!
  media: Manga!
  mangaId: UUID!
  manga: Manga!
  isAcceptProposal: Boolean
  creatorUserId: UUID
  createdAt: DateTime!
  updatedAt: DateTime!
}

directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION